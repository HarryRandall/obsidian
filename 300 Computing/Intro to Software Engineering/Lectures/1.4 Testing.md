---
course: "[[300 Computing/Intro to Software Engineering/Intro to Software Engineering|Intro to Software Engineering]]"
type: lecture
date: 2025-07-16
week: 1
session: 4
instructor: 
tags:
  - lecture
  - intro-to-software-engineering
  - testing
  - AB_testing
  - fuzzy_testing
status: in-progress
---

# Week 01 - Lecture 4

> [!info] Lecture Details
> **Course:** [[300 Computing/Intro to Software Engineering/Intro to Software Engineering|Intro to Software Engineering]]
> **Type:** Lecture
> **Date:** Wednesday, 16 July 2025
> **Week:** 1
> **Lecture #:** 4
> **Instructor:** 
> **Recording:** [Link]()

---

## Overview

Introduction to software testing covering types of testing, test automation, limitations of testing, fuzzing, performance testing, chaos engineering, and A/B testing.

---

## Key Concepts

### 1. Types of Testing

- **Functional Testing:** Validates software functionality against requirements (e.g., unit, feature and system testing).
- **Performance Testing:** Checks responsiveness, stability, and scalability under load.
- **Security Testing:** Identifies vulnerabilities, ensuring data protection.
- **Regression Testing:** Confirms that recent changes haven't introduced new bugs.
- **Boundary-Value Testing:** Tests edge cases to catch off-by-one and other boundary-related errors.

### 2. Test Automation

- Automates repetitive testing, ensuring consistency and saving time, especially in regression testing.
- **Unit Tests:** Fast, cover individual functions or methods.
- **Integration Tests:** Ensure multiple components interact correctly.
- **System Tests:** Full end-to-end tests simulating real user interactions.
- **Continuous Integration (CI):** Automatically runs tests with each code change.

### 3. Limitations of Testing

- **Coverage:** Achieving 100% coverage doesn't ensure complete reliability.
- **Oracle Problem:** Difficult to define expected outcomes for all possible scenarios.
- **Cost and Time:** Testing large systems thoroughly can be resource-intensive.
- Testing can't prove the absence of bugs, only detect their presence.

### 4. Fuzzing

- **Fuzz Testing:** Inputs random data to detect unexpected behaviours and crashes.
- Common for security testing, especially in low-level languages prone to memory issues.
- **Strengths:** Simple and effective for finding edge-case bugs.
- **Limitations:** May miss subtle bugs and requires handling of nonsensical inputs.

### 5. Performance Testing

- Evaluates the system's speed, resource usage, and scalability.
- **Stress Testing:** Puts system under extreme load to find breaking points.
- **Soak Testing:** Tests over extended periods to detect issues like memory leaks.
- Tools: JMeter, profiling tools, and real-time monitoring for identifying bottlenecks.

### 6. Chaos Engineering

- **Chaos Testing:** Deliberately induces failure to test system resilience (e.g., Netflix's Chaos Monkey).
- **Goals:** Expose weak points, validate redundancy, and prepare for disaster recovery.
- Tests involved simulated network failures, server crashes, and other disruptions.

### 7. A/B Testing

- Compares two versions (A and B) of a feature to measure user response.
- Used for UX improvements and feature validate by deploying different versions of subsets of users.
- Metrics from A/B tests can inform product decisions based on real user interactions.

---

## Notes

---

## Examples

> [!example] Testing Types
> - **Functional Testing:** Unit, feature, and system testing
> - **Performance Testing:** Stress testing, soak testing
> - **Security Testing:** Vulnerability identification
> - **Regression Testing:** Confirms no new bugs from changes

> [!example] Chaos Engineering
> Netflix's Chaos Monkey deliberately induces failures to test system resilience and expose weak points.

---

## Formulas & Definitions

| Term | Definition |
|------|------------|
| Functional Testing | Validates software functionality against requirements (e.g., unit, feature and system testing) |
| Performance Testing | Checks responsiveness, stability, and scalability under load |
| Security Testing | Identifies vulnerabilities, ensuring data protection |
| Regression Testing | Confirms that recent changes haven't introduced new bugs |
| Boundary-Value Testing | Tests edge cases to catch off-by-one and other boundary-related errors |
| Test Automation | Automates repetitive testing, ensuring consistency and saving time |
| Fuzz Testing | Inputs random data to detect unexpected behaviours and crashes |
| Stress Testing | Puts system under extreme load to find breaking points |
| Soak Testing | Tests over extended periods to detect issues like memory leaks |
| Chaos Engineering | Deliberately induces failure to test system resilience |
| A/B Testing | Compares two versions (A and B) of a feature to measure user response |

---

## Questions & Discussion

- [ ] What are the different types of testing and when should each be used?
- [ ] What are the benefits and limitations of test automation?
- [ ] How does fuzz testing work and when is it useful?
- [ ] What is chaos engineering and why is it important?
- [ ] How can A/B testing inform product decisions?

---

## Action Items

- [ ] Review lecture recording
- [ ] Complete practice questions
- [ ] Understand the different types of testing
- [ ] Review test automation strategies
- [ ] Study chaos engineering and A/B testing approaches

---

## Related Notes

- [[300 Computing/Intro to Software Engineering/Intro to Software Engineering|Course Summary]]
- [[300 Computing/Intro to Software Engineering/Lectures/1.3 Architecture|Week 01 - Lecture 3]]
- [[300 Computing/Intro to Software Engineering/Lectures/2.1 Team Culture|Week 02 - Lecture 1]]

---

## References
